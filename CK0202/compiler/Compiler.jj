/* SOURCE: https://javacc.org/javaccgrm */


/* >>>>>>>>>>>>>>>>>>> OPTIONS <<<<<<<<<<<<<<<<<<< */

options {
  /* Quando essa opção é setada como true, o parser gerado usa um objeto 
  input stream que processa java unicode scapes antes de mandar os caracteres
  ao token manager */
  JAVA_UNICODE_ESCAPE = true;

  /* Quando true, o token manager ignora case nas especificações do token
  e nos inout files */
  IGNORE_CASE = true;

  /* Quando true, todas as classes e métodos são especificados como static
  no parser gerado e no token manager */
  STATIC = true;

}

/*
	Todas as opções possíveis para options:

	option_binding	::=	"LOOKAHEAD" "=" java_integer_literal ";"
	|	"CHOICE_AMBIGUITY_CHECK" "=" java_integer_literal ";"
	|	"OTHER_AMBIGUITY_CHECK" "=" java_integer_literal ";"
	|	"STATIC" "=" java_boolean_literal ";"
	|	"SUPPORT_CLASS_VISIBILITY_PUBLIC" "=" java_boolean_literal ";"
	|	"DEBUG_PARSER" "=" java_boolean_literal ";"
	|	"DEBUG_LOOKAHEAD" "=" java_boolean_literal ";"
	|	"DEBUG_TOKEN_MANAGER" "=" java_boolean_literal ";"
	|	"ERROR_REPORTING" "=" java_boolean_literal ";"
	|	"JAVA_UNICODE_ESCAPE" "=" java_boolean_literal ";"
	|	"UNICODE_INPUT" "=" java_boolean_literal ";"
	|	"IGNORE_CASE" "=" java_boolean_literal ";"
	|	"USER_TOKEN_MANAGER" "=" java_boolean_literal ";"
	|	"USER_CHAR_STREAM" "=" java_boolean_literal ";"
	|	"BUILD_PARSER" "=" java_boolean_literal ";"
	|	"BUILD_TOKEN_MANAGER" "=" java_boolean_literal ";"
	|	"TOKEN_EXTENDS" "=" java_string_literal ";"
	|	"TOKEN_FACTORY" "=" java_string_literal ";"
	|	"TOKEN_MANAGER_USES_PARSER" "=" java_boolean_literal ";"
	|	"SANITY_CHECK" "=" java_boolean_literal ";"
	|	"FORCE_LA_CHECK" "=" java_boolean_literal ";"
	|	"COMMON_TOKEN_ACTION" "=" java_boolean_literal ";"
	|	"CACHE_TOKENS" "=" java_boolean_literal ";"
	|	"OUTPUT_DIRECTORY" "=" java_string_literal ";"

*/


/* >>>>>>>>>>>>>>>>>>> PARSER <<<<<<<<<<<<<<<<<<< */


PARSER_BEGIN(Compiler)

import syntaxtree.*;

	public class Compiler {
		public static void main(String args[]) throws ParseException, java.io.IOException {
			Compiler compiler;
			
			if(args.length == 0){
			  System.out.println("Iniciando Leitura de input padrão .. ");
        compiler = new Compiler(System.in);
			} 
			
			else if ( args.length == 1) {  
      	
      	compiler = new Compiler(new java.io.FileInputStream(args[0]));
      	compiler.Goal();
    
      } else {
       	System.out.println("Usar o programa \"compiler\" da seguinte maneira: \n"
       	+ "java Compiler < programa\n"
       	+ "\t---- Ou ----\njava Compiler programa"
       	);
				return;
       }
		}// END OF MAIN
	}// END OF CLASS

PARSER_END(Compiler)


/* >>>>>>>>>>>>>>>>>>> TOKENS <<<<<<<<<<<<<<<<<<< */

/* Ignorando espaços, tabs, novas linhas e compentários simplificados*/

SKIP : {
	" "
	| "\t"
	| "\n"
	| "\r"
	| "\f"
	|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}


/* palavras reservadas */
TOKEN :  {
	< AND : "and" >
	| <CLASS: "class">
	| <STATIC: "static">
	| <PUBLIC: "public">
	| <BOOL : "bool" >
	| <NEW: "new">
	| <CONST : "const" >
	| <PRINT: "System.out.println">
	| <LENGTH: "length">
	| <DO : "do" >
	| <ELSE : "else" >
	| <FALSE : "false" >
	| <IF : "if" >
	| <INT : "int" >
	| <MAIN : "main" >
	| <NOT : "not" >
	| <OR : "or" >
	| <REAL : "real" >
	| <RETURN : "return" >
	| <THEN : "then" >
	| <TRUE : "true" >
	| <VAR : "var" >
	| <VOID : "void" >
	| <WHILE : "while" >
	| <STRING: "String">
	| <EXTENDS: "extends">
	| <THIS: "this">
	| <INTEGER_LITERAL: (["0"-"9"])+>
	| <ID: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9", "_"])*>
}


/* operadores, pontuações */
TOKEN :  {
		
		<OPERATOR: "&&"|"<"|"+"|"-"|"*">
	| <MODULUS : "%" >
	| <EQUALS : "=" >
	| <NOTEQUALS : "!=" >
	| <LESSEQUAL : "<=" >
	| <GREATEREQUAL : ">=" >
	| <LPAREN: "(" >
	| <RPAREN: ")" >
	| <OPENBRACKET : "[" >
	| <CLOSEBRACKET : "]" >
	| <OPENCURLY : "{" >
	| <CLOSECURLY : "}" >
	| <COMMA : "," >
	| <SEMIC : ";" >
	| <COLON : ":" >
	| <DOT : "." >
	| <ASSIGNMENT : ":=" >
	| <QUESTIONMARK : "?" >
	| <EXCLAMATION : "!" >
}

/* >>>>>>>>>>>>>>>>>>> REGRAS DE PRODUÇÃO <<<<<<<<<<<<<<<<<<< */

void Id(): {} {
  <ID>
}

// definindo um tipo de metodo expression
void Expression(): {} {
  (
      <NEW> ((<INT> "[" Expression() "]")|(Id() "(" ")"))
    | <INTEGER_LITERAL>
    | <BOOL>
    | Id()
    | <THIS>
    | ("!" Expression())
    | ("(" Expression() ")")
  )
  ( 

/*
	O número de tokens para olhar para frente antes de tomar uma decisão em um
	ponto de escolha durante a análise. O valor padrão é 1. Quanto menor esse
	número, mais rápido será o analisador. Esse número pode ser substituído por
	produções específicas dentro da gramática, conforme descrito posteriormente.

*/
    LOOKAHEAD(2) 
    ( 
        ("." (<LENGTH>|(Id() "(" [Expression() ("," Expression())*] ")")))
      | ("[" Expression() "]")
      | (<OPERATOR> Expression())
    )
  )*
}

void Statement(): {} {
  ("{" (Statement())* "}")
| (<IF> "(" Expression() ")" Statement() <ELSE> Statement())
| (<WHILE> "(" Expression() ")" Statement())
| (<PRINT> "(" Expression() ")" ";")
| (Id() ["[" Expression() "]"] "=" Expression() ";")
}

void StatementList(): {} {
	Statement() (Statement())*
}

void VarDeclaration(): {} {
  Type() Id() ";"  
}

void Type(): {} {
  (<INT> ["[" "]"])
| <BOOL>
| Id()
}

// metodo goal
void Goal(): {} {

  MainClass()
  (ClassDeclaration())*
  <EOF>
}

// classe main
void MainClass(): {} {
  <CLASS> Id()
  "{"
    <PUBLIC> <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" Id() ")"
    "{"
       Statement()
    "}"
  "}"
}

// classe podendo estender a outra 
void ClassDeclaration(): {} {
  <CLASS> Id() [<EXTENDS> Id()]
  "{"
    (VarDeclaration())*
    (MethodDeclaration())*
  "}"
}

void ClassDeclList() : {} { ( ClassDeclaration() )* }

void MethodDeclaration(): {} {
  <PUBLIC> Type() Id() "(" [Type() Id() ("," Type() Id())*] ")"
  "{"
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
    <RETURN> Expression() ";"
  "}"
}


/* >>>>>>>>>>>>>>>>>>>  REGRAS DE PRODUÇÃO PARA OS NÓS DA ÁRVORE <<<<<<<<<<<<<<<<<<< */

void Block() : {} { <OPENCURLY> [StatementList()] <CLOSECURLY> }
void If() : {} { <IF> <LPAREN> Exp() <RPAREN> Statement() <ELSE> Statement() }
void Print() : {} { <PRINT> <LPAREN> Exp() <RPAREN> <SEMIC> }
void While() : {} { <WHILE> <LPAREN> Exp() <RPAREN> Statement() }
void Assign() : {} { Id() <ASSIGN> Expression() <SEMIC> }

 Type Type() : 
 	{ Type t; } 
 		{ (t=BooleanType() | t=IdentifierType() | t=IntOrIntArrayType() /*LOOKAHEAD(2) t=IntArrayType() | t=IntegerType()*/) { return t; } 
 	}
 Type BooleanType() : 
 	{} 
		{ <BOOLEAN> { return new BooleanType(getPosition()); } 
	}
	
 // ambiguidade? 
 Type IdentifierType() : 
 	{ Identifier i; } 
		{ i=Identifier() { return new IdentifierType(i.s, getPosition()); }
	}

 Identifier Identifier() : 
 	{ Token t; } 
 		{ t=<ID> { return new Identifier(t.image, getPosition()); } 
 	}